<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title></title>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script type="text/javascript" src="static/jsts.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
   integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
   crossorigin=""/>
 <!-- Make sure you put this AFTER Leaflet's CSS -->
 <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
   integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
   crossorigin=""></script>
<script src="https://stamen-maps.a.ssl.fastly.net/js/tile.stamen.js"></script>
<style>

html, body {
  margin: 0;
}

#map {
  height: 720px;
  width: 100%;
}

path {
  stroke-width: 2px;
}

path.ward-outline {
  fill: none;
}

.selected {
  stroke: red;
  fill: red;
  fill-opacity: 0.3;
}

.selected2 {
  stroke: blue;
  fill: blue;
  fill-opacity: 0.3;
}

.selected.selected2 {
  stroke: purple;
  fill-opacity: 0;
}

.leaflet-overlay-pane svg path{
  pointer-events: auto;
}

#caption {
  font-size: 20px;
}

</style>
</head>
<body>
<div id="map"></div>
<div id="caption"></div>
<script>
var pi = Math.PI,
    tau = 2 * pi;

var width = window.innerWidth,
    height = window.innerHeight-5,
    rTree = new jsts.index.strtree.STRtree(),
    rTree2 = new jsts.index.strtree.STRtree(),
    geometryFactory = new jsts.geom.GeometryFactory(),
    reader = new jsts.io.GeoJSONReader(),
    writer = new jsts.io.GeoJSONWriter();

// initialize map
var map = new L.Map("map", {
    center: [41.87, -87.62],
    zoom: 11,
    zoomControl: false,
});

map.addLayer(new L.StamenTileLayer("toner-lite"));

// add svg overlay to map
L.svg().addTo(map); // render all paths with SVG

var svg = d3.select("#map").select("svg");

d3.queue()
  .defer(d3.json, "districts/wards.topojson")
  .defer(d3.json, "districts/ilhouse.topojson")
  .defer(d3.json, "districts/ushouse.topojson")
  .await(ready);

function ready(error, wards, ilhouse, ushouse) {
  var transform = d3.geoTransform({point: projectPoint}),
      path = d3.geoPath().projection(transform);

  var wardTopo = topojson.feature(wards, wards.objects.wards).features;

  wards = svg.selectAll("path.ward")
      .data(wardTopo)
    .enter().append("path")
      .attr("class","ward-outline")
      .attr("stroke", "none");

  var feat = topojson.feature(ilhouse, ilhouse.objects.districts),
      filtered = feat.features.filter(d => d.properties.NAME == "4");

  district = svg.selectAll("path.sl")
      .data(filtered)
    .enter().append("path")
      .attr("class", "sl-outline")
      .attr("stroke", "red")
      .attr("fill", "red")
      .attr("fill-opacity", 0.3)

  var feat = topojson.feature(ushouse, ushouse.objects.districts),
      filtered = feat.features.filter(d => d.properties.CD115FP == "4");

  district2 = svg.selectAll("path.sl")
      .data(filtered)
    .enter().append("path")
      .attr("class", "cd-outline")
      .attr("stroke", "blue")
      .attr("fill", "blue")
      .attr("fill-opacity", 0.3)

  wardTopo.map(d => {
    d.polygon = reader.read(d.geometry)
    rTree.insert(d.polygon.getEnvelopeInternal(), d)
  });

  var ints = addIntersection(ilhouse, "districts", "NAME", "4", "selected", rTree),
      ints2 = addSecondIntersection(ints, ushouse, "districts", "CD115FP",  "4", "selected selected2", rTree2);

  var ints3 = svg.selectAll("path.selected.selected2")
    .data(ints2)
  .enter().append("path")
    .attr("class","ints-outline selected selected2")
    .on("mouseover", function(d) {
      d3.select(this).style("fill-opacity", 0.3);
      console.log(d.properties.ward)

      d3.select("#caption").html("Ward " + d.properties.ward + " intersects both IL-4 & State Leg Dist 4 here")
    })
    .on("mouseout", function(d) {
      d3.select(this).style("fill-opacity", 0);
    })

  map.on("moveend", reset);
  reset();
  
  // reposition SVG on map on zoom/translate
  function reset() {
    wards.attr("d", path);
    district.attr("d", path)
    district2.attr("d", path)
    //district.attr("d", path);
    //ints.attr("d", d => {var x = path(d); if (x != "Z") return x})
    ints3.attr("d", d => {var x = path(d); if (x != "Z") return x})
  }
};

function projectPoint(x, y) {
  var point = map.latLngToLayerPoint(new L.LatLng(y, x));
  this.stream.point(point.x, point.y);
}

function addIntersection(topo, featName, propName, propValue, className, rt) {
  var feat = topojson.feature(topo, topo.objects[featName]),
      filtered = feat.features.filter(d => d.properties[propName] == propValue);

  //var extent = filtered[0].geometry.coordinates[0];

  /*district = svg.selectAll("path.sl")
      .data(filtered)
    .enter().append("path")
      .attr("class", "sl-outline")
      .attr("stroke", "red");*/

  //wards.each(d => d.selected = false);

  var searchPolygon = reader.read(filtered[0].geometry)

  var intersections = [];
  rt.query(searchPolygon.getEnvelopeInternal()).array_.forEach(function(d) {
    var intersection = d.polygon.intersection(searchPolygon);
    intersections.push({"type": "Feature", "geometry": intersection, "properties": d.properties})
    //intersection ? d.selected = true : d.selected = false
  })

  intersectionsGeoJSON = intersections.map(d => ({"type": "Feature", "geometry": writer.write(d.geometry), "properties": d.properties}));

  /*
  var ints = svg.selectAll("path." + className)
      .data(intersectionsGeoJSON)
    .enter().append("path")
      .attr("class","ints-outline " + className)
      .on("mouseover", function(d) {
        d3.select(this).style("fill-opacity", 0.6);
        console.log(d.properties.ward)
      })
      .on("mouseout", function(d) {
        d3.select(this).style("fill-opacity", 0.3);
      })*/

  return intersectionsGeoJSON
}

function addSecondIntersection(intersection, topo, featName, propName, propValue, className, rt){
  /*intersection.append("title")
    .each(d => {
      d.polygon = reader.read(d.geometry)
      rt.insert(d.polygon.getEnvelopeInternal(), d)
    })*/

  intersection.map(d => {
    d.polygon = reader.read(d.geometry)
    rt.insert(d.polygon.getEnvelopeInternal(), d)
  })

  ints = addIntersection(topo, featName, propName, propValue, className, rt);
  console.log(ints)
  return ints
}

</script>
</body>